import { GenericObject, isUndefined } from '@util/types'
import { arrayToObject, clearObject, createObjectByStringPath, insertValueInObjectByPath } from '@util/geral'
import { DTO } from '@util/dto'
import { QuerySearchDTO } from '@services/query-builder/schema'
import { z } from '@services/validator'
import type { TParamType } from '@services/query-builder/types'
import { GLOBAL_QUERY_SEARCH_HANDLER_VALUES } from '@services/query-builder/filter'

export type RelationMapQuery = {
    field: string,
    filter?: string,
    type: TParamType,
    excludesOperators?: string[],
    typeOperation: 'SCHEMA' | 'UNIQUE' | 'MANY_VALUES'
    required?: boolean
}

export type RelationMapOrderBy = {
    field: string,
    filter?: string,
}

export class QueryBuilder {

    constructor(
        private mapRelationQuery: RelationMapQuery[] = [],
        private mapRelationOrderBy: RelationMapOrderBy[] = [],
        private defaultOrdersBy: { [x: string]: 'asc' | 'desc' }[] = []
    ) { }

    createQuery(filtersArgs: GenericObject, orderByArgs: GenericObject[]) {
        const { filters } = this.createFilters(filtersArgs)
        const { orderBy } = this.createOrderBy(orderByArgs)

        return { filters, orderBy }
    }

    createFilters(filtersArgs: GenericObject) {
        const filters = {}
        let AND: any[] = []

        for (const { field: fieldName, filter: filterName = fieldName, type, typeOperation, excludesOperators } of this.mapRelationQuery) {
            const filter = filtersArgs[filterName]

            const value = typeOperation == 'SCHEMA' ? this.getFilterValuesInProp(filter, { type, excludesOperators }) : filter

            createObjectByStringPath(fieldName, filters)

            if (typeOperation == 'SCHEMA' && type == 'STRING') {
                if (!isUndefined(value.contains)) {
                    const newValue = value.contains.split(' ').map(word => {
                        const obj = createObjectByStringPath(fieldName)

                        insertValueInObjectByPath(obj, { contains: word, mode: 'insensitive' }, fieldName)

                        return obj
                    })

                    AND.push(...newValue)

                    value.contains = undefined

                    if (Object.keys(value).length == 2 && value.mode)
                        value.mode = undefined
                }
                if (!isUndefined(value.not) && !isUndefined(value.not.contains)) {
                    const newValue = value.not.contains.split(' ').map(word => {
                        const obj = createObjectByStringPath(`NOT.${fieldName}`)

                        insertValueInObjectByPath(obj, { contains: word, mode: 'insensitive' }, `NOT.${fieldName}`)

                        return obj
                    })

                    AND.push(...newValue)

                    value.not.contains = undefined

                    if (Object.keys(value).length == 2 && value.mode)
                        value.mode = undefined
                }
            }

            insertValueInObjectByPath(filters, value, fieldName)
        }

        return { filters: { ...clearObject<GenericObject>({ ...filters, AND }) } }
    }

    createOrderBy(orderByArgs: GenericObject[]) {
        const fullOrdersByArgs = arrayToObject(orderByArgs)
        const ordersBy: GenericObject[] = []

        for (const key in fullOrdersByArgs) {
            const relation = this.mapRelationOrderBy.find(({ field, filter = field }) => filter == key)

            if (!relation) continue

            const { field: fieldName, filter: filterName = fieldName } = relation

            if (isUndefined(fullOrdersByArgs[filterName]))
                continue

            const orderBy = createObjectByStringPath(fieldName)
            insertValueInObjectByPath(orderBy, fullOrdersByArgs[filterName], fieldName)
            ordersBy.push(orderBy)
        }

        return { orderBy: [...ordersBy, ...this.defaultOrdersBy] }
    }

    /**
     * @deprecated Instead of using the schema generated by QueryBuilder, create the schema using z
     */
    getSchema() {
        const schema: any = {}
        const orderBy = this.mapRelationOrderBy.map(({ field, filter = field }) => filter)

        for (let i = 0; i < this.mapRelationQuery.length; i++) {
            const { field, filter = field, type, typeOperation, required = false } = this.mapRelationQuery[i]
            let filterParam: any = type != 'ENUM' ? QuerySearchDTO[type].SCHEMA(filter) : QuerySearchDTO[type].SCHEMA(filter)

            if (typeOperation == 'SCHEMA') {
                filterParam = z.object(filterParam)
            }

            if (!required)
                filterParam = filterParam.optional()

            schema[filter] = filterParam
        }

        return DTO.query.schema({ orders: orderBy }).extend(schema)
    }

    private getFilterValuesInProp(filters: any, { type, excludesOperators }: { type: TParamType, excludesOperators?: string[] }) {
        const handler = GLOBAL_QUERY_SEARCH_HANDLER_VALUES[type]

        if (!handler) {
            return {}
        }

        return handler(filters, { excludesOperators })
    }
}